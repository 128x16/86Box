Comparing files CPU\codegen.h and CPU_NEW\CODEGEN.H
***** CPU\codegen.h
/*
 * VARCem       Virtual ARchaeological Computer EMulator.
 *              An emulator of (mostly) x86-based PC systems and devices,
 *              using the ISA,EISA,VLB,MCA  and PCI system buses, roughly
 *              spanning the era between 1981 and 1995.
 *
 *              This file is part of the VARCem Project.
 *
 *              Definitions for the code generator.
 *
 * Version:     @(#)codegen.h   1.0.2   2018/03/14
 *
 * Authors:     Sarah Walker, <tommowalker@tommowalker.co.uk>
 *              Miran Grca, <mgrca8@gmail.com>
 *
 *              Copyright 2008-2018 Sarah Walker.
 *              Copyright 2016-2018 Miran Grca.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free  Software  Foundation; either  version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is  distributed in the hope that it will be useful, but
 * WITHOUT   ANY  WARRANTY;  without  even   the  implied  warranty  of
 * MERCHANTABILITY  or FITNESS  FOR A PARTICULAR  PURPOSE. See  the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the:
 *
 *   Free Software Foundation, Inc.
 *   59 Temple Place - Suite 330
 *   Boston, MA 02111-1307
 *   USA.
 */
#ifndef _CODEGEN_H_
#define _CODEGEN_H_
***** CPU_NEW\CODEGEN.H
#ifndef _CODEGEN_H_
#define _CODEGEN_H_
*****

***** CPU\codegen.h

#include "../mem.h"
#include "../cpu_common/x86_ops.h"
***** CPU_NEW\CODEGEN.H

#include "mem.h"
#include "../cpu_common/x86_ops.h"
*****

***** CPU\codegen.h

#ifdef __amd64__
#include "codegen_x86-64.h"
#elif defined i386 || defined __i386 || defined __i386__ || defined _X86_ || defined _M_IX86 || defined _M_X64
#include "codegen_x86.h"
#else
#error Dynamic recompiler not implemented on your platform
#endif

/*Handling self-modifying code (of which there is a lot on x86) :
***** CPU_NEW\CODEGEN.H

/*Handling self-modifying code (of which there is a lot on x86) :
*****

***** CPU\codegen.h
{
        uint64_t page_mask, page_mask2;
        uint64_t *dirty_mask, *dirty_mask2;
        uint64_t cmp;
        
        /*Previous and next pointers, for the codeblock list associated with
          each physical page. Two sets of pointers, as a codeblock can be
          present in two pages.*/
        struct codeblock_t *prev, *next;
        struct codeblock_t *prev_2, *next_2;
        
        /*Pointers for codeblock tree, used to search for blocks when hash lookup
***** CPU_NEW\CODEGEN.H
{
        uint32_t pc;
        uint32_t _cs;
        uint32_t phys, phys_2;
        uint16_t status;
        uint16_t flags;
        uint8_t ins;
        uint8_t TOP;

        /*Pointers for codeblock tree, used to search for blocks when hash lookup
*****

***** CPU\codegen.h
          fails.*/
        struct codeblock_t *parent, *left, *right;
        
        int pnt;
        int ins;

        int valid;

        int was_recompiled;
        int TOP;

        uint32_t pc;
        uint32_t _cs;
        uint32_t endpc;
        uint32_t phys, phys_2;
        uint32_t status;
        uint32_t flags;

        uint8_t data[2048];
} codeblock_t;
***** CPU_NEW\CODEGEN.H
          fails.*/
        uint16_t parent, left, right;

        uint8_t *data;
        
        uint64_t page_mask, page_mask2;
        uint64_t *dirty_mask, *dirty_mask2;

        /*Previous and next pointers, for the codeblock list associated with
          each physical page. Two sets of pointers, as a codeblock can be
          present in two pages.*/
        uint16_t prev, next;
        uint16_t prev_2, next_2;

        /*First mem_block_t used by this block. Any subsequent mem_block_ts
          will be in the list starting at head_mem_block->next.*/
        struct mem_block_t *head_mem_block;
} codeblock_t;
*****

***** CPU\codegen.h

/*Code block uses FPU*/
***** CPU_NEW\CODEGEN.H

extern codeblock_t *codeblock;

extern uint16_t *codeblock_hash;

extern uint8_t *block_write_data;

/*Code block uses FPU*/
*****

***** CPU\codegen.h
#define CODEBLOCK_STATIC_TOP 2

***** CPU_NEW\CODEGEN.H
#define CODEBLOCK_STATIC_TOP 2
/*Code block has been compiled*/
#define CODEBLOCK_WAS_RECOMPILED 4
/*Code block is in free list and is not valid*/
#define CODEBLOCK_IN_FREE_LIST 8
/*Code block spans two pages, page_mask2 and dirty_mask2 are valid*/
#define CODEBLOCK_HAS_PAGE2 0x10
/*Code block is using a byte mask for code present and dirty*/
#define CODEBLOCK_BYTE_MASK 0x20
/*Code block is in dirty list*/
#define CODEBLOCK_IN_DIRTY_LIST 0x40
/*Code block is not inlining immediate parameters, parameters must be fetched from memory*/
#define CODEBLOCK_NO_IMMEDIATES 0x80

#define BLOCK_PC_INVALID 0xffffffff

#define BLOCK_INVALID 0

static inline int get_block_nr(codeblock_t *block)
{
        return ((uintptr_t)block - (uintptr_t)codeblock) / sizeof(codeblock_t);
}

*****

***** CPU\codegen.h
{
        codeblock_t *block = pages[phys >> 12].head;
        uint64_t a = _cs | ((uint64_t)phys << 32);
***** CPU_NEW\CODEGEN.H
{
        codeblock_t *block;
        uint64_t a = _cs | ((uint64_t)phys << 32);
*****

***** CPU\codegen.h
        
        while (block)
***** CPU_NEW\CODEGEN.H
        
        if (!pages[phys >> 12].head)
                return NULL;
                
        block = &codeblock[pages[phys >> 12].head];
        while (block)
*****

***** CPU\codegen.h
        {
                if (a == block->cmp)
                {
***** CPU_NEW\CODEGEN.H
        {
                uint64_t block_cmp = block->_cs | ((uint64_t)block->phys << 32);
                if (a == block_cmp)
                {
*****

***** CPU\codegen.h
                }
                if (a < block->cmp)
                        block = block->left;
                else
                        block = block->right;
        }
***** CPU_NEW\CODEGEN.H
                }
                if (a < block_cmp)
                        block = block->left ? &codeblock[block->left] : NULL;
                else
                        block = block->right ? &codeblock[block->right] : NULL;
        }
*****

***** CPU\codegen.h
{
        codeblock_t *block = pages[new_block->phys >> 12].head;
        uint64_t a = new_block->_cs | ((uint64_t)new_block->phys << 32);
        new_block->cmp = a;
                
        if (!block)
        {
                pages[new_block->phys >> 12].head = new_block;
                new_block->parent = new_block->left = new_block->right = NULL;
        }
***** CPU_NEW\CODEGEN.H
{
        codeblock_t *block = &codeblock[pages[new_block->phys >> 12].head];
        uint64_t a = new_block->_cs | ((uint64_t)new_block->phys << 32);

        if (!pages[new_block->phys >> 12].head)
        {
                pages[new_block->phys >> 12].head = get_block_nr(new_block);
                new_block->parent = new_block->left = new_block->right = BLOCK_INVALID;
        }
*****

***** CPU\codegen.h
                codeblock_t *old_block = NULL;
                
***** CPU_NEW\CODEGEN.H
                codeblock_t *old_block = NULL;
                uint64_t old_block_cmp = 0;
                
*****

***** CPU\codegen.h
                        old_block = block;
                        if (a < old_block->cmp)
                                block = block->left;
                        else
                                block = block->right;
                }
***** CPU_NEW\CODEGEN.H
                        old_block = block;
                        old_block_cmp = old_block->_cs | ((uint64_t)old_block->phys << 32);
                        
                        if (a < old_block_cmp)
                                block = block->left ? &codeblock[block->left] : NULL;
                        else
                                block = block->right ? &codeblock[block->right] : NULL;
                }
*****

***** CPU\codegen.h
                
                if (a < old_block->cmp)
                        old_block->left = new_block;
                else
                        old_block->right = new_block;
                
                new_block->parent = old_block;
                new_block->left = new_block->right = NULL;
        }
***** CPU_NEW\CODEGEN.H
                
                if (a < old_block_cmp)
                        old_block->left = get_block_nr(new_block);
                else
                        old_block->right = get_block_nr(new_block);
                
                new_block->parent = get_block_nr(old_block);
                new_block->left = new_block->right = BLOCK_INVALID;
        }
*****

***** CPU\codegen.h
{
        codeblock_t *parent = block->parent;

***** CPU_NEW\CODEGEN.H
{
        uint16_t parent_nr = block->parent;
        codeblock_t *parent;

        if (block->parent)
                parent = &codeblock[block->parent];
        else
                parent = NULL;

*****

***** CPU\codegen.h
                if (!parent)
                        pages[block->phys >> 12].head = NULL;
                else
***** CPU_NEW\CODEGEN.H
                if (!parent)
                        pages[block->phys >> 12].head = BLOCK_INVALID;
                else
*****

***** CPU\codegen.h
                {
                        if (parent->left == block)
                                parent->left = NULL;
                        if (parent->right == block)
                                parent->right = NULL;
                }
***** CPU_NEW\CODEGEN.H
                {
                        uint16_t block_nr = get_block_nr(block);
                        
                        if (parent->left == block_nr)
                                parent->left = BLOCK_INVALID;
                        if (parent->right == block_nr)
                                parent->right = BLOCK_INVALID;
                }
*****

***** CPU\codegen.h
                /*Only right node*/
                if (!parent)
                {
***** CPU_NEW\CODEGEN.H
                /*Only right node*/
                if (!parent_nr)
                {
*****

***** CPU\codegen.h
                        pages[block->phys >> 12].head = block->right;
                        pages[block->phys >> 12].head->parent = NULL;
                }
***** CPU_NEW\CODEGEN.H
                        pages[block->phys >> 12].head = block->right;
                        codeblock[pages[block->phys >> 12].head].parent = BLOCK_INVALID;
                }
*****

***** CPU\codegen.h
                {
                        if (parent->left == block)
                        {
***** CPU_NEW\CODEGEN.H
                {
                        uint16_t block_nr = get_block_nr(block);

                        if (parent->left == block_nr)
                        {
*****

***** CPU\codegen.h
                                parent->left = block->right;
                                parent->left->parent = parent;
                        }
                        if (parent->right == block)
                        {
***** CPU_NEW\CODEGEN.H
                                parent->left = block->right;
                                codeblock[parent->left].parent = parent_nr;
                        }
                        if (parent->right == block_nr)
                        {
*****

***** CPU\codegen.h
                                parent->right = block->right;
                                parent->right->parent = parent;
                        }
***** CPU_NEW\CODEGEN.H
                                parent->right = block->right;
                                codeblock[parent->right].parent = parent_nr;
                        }
*****

***** CPU\codegen.h
                /*Only left node*/
                if (!parent)
                {
***** CPU_NEW\CODEGEN.H
                /*Only left node*/
                if (!parent_nr)
                {
*****

***** CPU\codegen.h
                        pages[block->phys >> 12].head = block->left;
                        pages[block->phys >> 12].head->parent = NULL;
                }
***** CPU_NEW\CODEGEN.H
                        pages[block->phys >> 12].head = block->left;
                        codeblock[pages[block->phys >> 12].head].parent = BLOCK_INVALID;
                }
*****

***** CPU\codegen.h
                {
                        if (parent->left == block)
                        {
***** CPU_NEW\CODEGEN.H
                {
                        uint16_t block_nr = get_block_nr(block);

                        if (parent->left == block_nr)
                        {
*****

***** CPU\codegen.h
                                parent->left = block->left;
                                parent->left->parent = parent;
                        }
                        if (parent->right == block)
                        {
***** CPU_NEW\CODEGEN.H
                                parent->left = block->left;
                                codeblock[parent->left].parent = parent_nr;
                        }
                        if (parent->right == block_nr)
                        {
*****

***** CPU\codegen.h
                                parent->right = block->left;
                                parent->right->parent = parent;
                        }
***** CPU_NEW\CODEGEN.H
                                parent->right = block->left;
                                codeblock[parent->right].parent = parent_nr;
                        }
*****

***** CPU\codegen.h
                /*Difficult case - node has two children. Walk right child to find lowest node*/
                codeblock_t *lowest = block->right, *highest;
                codeblock_t *old_parent;
                        
***** CPU_NEW\CODEGEN.H
                /*Difficult case - node has two children. Walk right child to find lowest node*/
                codeblock_t *lowest = &codeblock[block->right], *highest;
                codeblock_t *old_parent;
                uint16_t lowest_nr;
                        
*****

***** CPU\codegen.h
                while (lowest->left)
                        lowest = lowest->left;

                old_parent = lowest->parent;

***** CPU_NEW\CODEGEN.H
                while (lowest->left)
                        lowest = &codeblock[lowest->left];
                lowest_nr = get_block_nr(lowest);
                
                old_parent = &codeblock[lowest->parent];

*****

***** CPU\codegen.h
                /*Replace deleted node with lowest node*/
                if (!parent)
                        pages[block->phys >> 12].head = lowest;
                else
***** CPU_NEW\CODEGEN.H
                /*Replace deleted node with lowest node*/
                if (!parent_nr)
                        pages[block->phys >> 12].head = lowest_nr;
                else
*****

***** CPU\codegen.h
                {
                        if (parent->left == block)
                                parent->left = lowest;
                        if (parent->right == block)
                                parent->right = lowest;
                }
***** CPU_NEW\CODEGEN.H
                {
                        uint16_t block_nr = get_block_nr(block);

                        if (parent->left == block_nr)
                                parent->left = lowest_nr;
                        if (parent->right == block_nr)
                                parent->right = lowest_nr;
                }
*****

***** CPU\codegen.h

                lowest->parent = parent;
                lowest->left = block->left;
***** CPU_NEW\CODEGEN.H

                lowest->parent = parent_nr;
                lowest->left = block->left;
*****

***** CPU\codegen.h
                if (lowest->left)
                        lowest->left->parent = lowest;

                old_parent->left = NULL;
                                
                highest = lowest->right;
                if (!highest)
                {
                        if (lowest != block->right)
                        {
***** CPU_NEW\CODEGEN.H
                if (lowest->left)
                        codeblock[lowest->left].parent = lowest_nr;

                old_parent->left = BLOCK_INVALID;
                                
                highest = &codeblock[lowest->right];
                if (!lowest->right)
                {
                        if (lowest_nr != block->right)
                        {
*****

***** CPU\codegen.h
                                lowest->right = block->right;
                                block->right->parent = lowest;
                        }
***** CPU_NEW\CODEGEN.H
                                lowest->right = block->right;
                                codeblock[block->right].parent = lowest_nr;
                        }
*****

***** CPU\codegen.h
                while (highest->right)
                        highest = highest->right;

                if (block->right && block->right != lowest)
                {
***** CPU_NEW\CODEGEN.H
                while (highest->right)
                        highest = &codeblock[highest->right];

                if (block->right && block->right != lowest_nr)
                {
*****

***** CPU\codegen.h
                        highest->right = block->right;
                        block->right->parent = highest;
                }
***** CPU_NEW\CODEGEN.H
                        highest->right = block->right;
                        codeblock[block->right].parent = get_block_nr(highest);
                }
*****

***** CPU\codegen.h

#define PAGE_MASK_INDEX_MASK 3
#define PAGE_MASK_INDEX_SHIFT 10
#define PAGE_MASK_MASK 63
#define PAGE_MASK_SHIFT 4

extern codeblock_t *codeblock;

extern codeblock_t **codeblock_hash;

***** CPU_NEW\CODEGEN.H

#define PAGE_MASK_MASK 63
#define PAGE_MASK_SHIFT 6

void codegen_mark_code_present_multibyte(codeblock_t *block, uint32_t start_pc, int len);

static inline void codegen_mark_code_present(codeblock_t *block, uint32_t start_pc, int len)
{
        if (len == 1)
        {
                if (block->flags & CODEBLOCK_BYTE_MASK)
                {
                        if (!((start_pc ^ block->pc) & ~0x3f)) /*Starts in second page*/
                                block->page_mask |= ((uint64_t)1 << (start_pc & PAGE_MASK_MASK));
                        else
                                block->page_mask2 |= ((uint64_t)1 << (start_pc & PAGE_MASK_MASK));
                }
                else
                {
                        if (!((start_pc ^ block->pc) & ~0xfff)) /*Starts in second page*/
                                block->page_mask |= ((uint64_t)1 << ((start_pc >> PAGE_MASK_SHIFT) & PAGE_MASK_MASK));
                        else
                                block->page_mask2 |= ((uint64_t)1 << ((start_pc >> PAGE_MASK_SHIFT) & PAGE_MASK_MASK));
                }
        }
        else
                codegen_mark_code_present_multibyte(block, start_pc, len);
}

*****

***** CPU\codegen.h
void codegen_init();
void codegen_reset();
***** CPU_NEW\CODEGEN.H
void codegen_init();
void codegen_close();
void codegen_reset();
*****

***** CPU\codegen.h
void codegen_block_end();
void codegen_generate_call(uint8_t opcode, OpFn op, uint32_t fetchdat, uint32_t new_pc, uint32_t old_pc);
***** CPU_NEW\CODEGEN.H
void codegen_block_end();
void codegen_delete_block(codeblock_t *block);
void codegen_generate_call(uint8_t opcode, OpFn op, uint32_t fetchdat, uint32_t new_pc, uint32_t old_pc);
*****

***** CPU\codegen.h
void codegen_flush();
void codegen_check_flush(page_t *page, uint64_t mask, uint32_t phys_addr);

***** CPU_NEW\CODEGEN.H
void codegen_flush();
void codegen_check_flush(struct page_t *page, uint64_t mask, uint32_t phys_addr);
struct ir_data_t;
x86seg *codegen_generate_ea(struct ir_data_t *ir, x86seg *op_ea_seg, uint32_t fetchdat, int op_ssegs, uint32_t *op_pc, uint32_t
 op_32, int stack_offset);
void codegen_check_seg_read(codeblock_t *block, struct ir_data_t *ir, x86seg *seg);
void codegen_check_seg_write(codeblock_t *block, struct ir_data_t *ir, x86seg *seg);

int codegen_purge_purgable_list();
/*Delete a random code block to free memory. This is obviously quite expensive, and
  will only be called when the allocator is out of memory*/
void codegen_delete_random_block(int required_mem_block);

*****

***** CPU\codegen.h
extern void (*codegen_timing_prefix)(uint8_t prefix, uint32_t fetchdat);
extern void (*codegen_timing_opcode)(uint8_t opcode, uint32_t fetchdat, int op_32);
extern void (*codegen_timing_block_start)();
***** CPU_NEW\CODEGEN.H
extern void (*codegen_timing_prefix)(uint8_t prefix, uint32_t fetchdat);
extern void (*codegen_timing_opcode)(uint8_t opcode, uint32_t fetchdat, int op_32, uint32_t op_pc);
extern void (*codegen_timing_block_start)();
*****

***** CPU\codegen.h
extern void (*codegen_timing_block_end)();

***** CPU_NEW\CODEGEN.H
extern void (*codegen_timing_block_end)();
extern int (*codegen_timing_jump_cycles)();

*****

***** CPU\codegen.h
        void (*prefix)(uint8_t prefix, uint32_t fetchdat);
        void (*opcode)(uint8_t opcode, uint32_t fetchdat, int op_32);
        void (*block_start)();
***** CPU_NEW\CODEGEN.H
        void (*prefix)(uint8_t prefix, uint32_t fetchdat);
        void (*opcode)(uint8_t opcode, uint32_t fetchdat, int op_32, uint32_t op_pc);
        void (*block_start)();
*****

***** CPU\codegen.h
        void (*block_end)();
} codegen_timing_t;
***** CPU_NEW\CODEGEN.H
        void (*block_end)();
        int (*jump_cycles)();
} codegen_timing_t;
*****

***** CPU\codegen.h
extern codegen_timing_t codegen_timing_winchip;

***** CPU_NEW\CODEGEN.H
extern codegen_timing_t codegen_timing_winchip;
extern codegen_timing_t codegen_timing_winchip2;
extern codegen_timing_t codegen_timing_k6;

*****

***** CPU\codegen.h

static inline void addbyte(uint8_t val)
{
        codeblock[block_current].data[block_pos++] = val;
        if (block_pos >= BLOCK_MAX)
        {
                CPU_BLOCK_END();
        }
}

static inline void addword(uint16_t val)
{
        uint16_t *p = (uint16_t *) &codeblock[block_current].data[block_pos];
        *p = val;
        block_pos += 2;
        if (block_pos >= BLOCK_MAX)
        {
                CPU_BLOCK_END();
        }
}

static inline void addlong(uint32_t val)
{
        uint32_t *p = (uint32_t *) &codeblock[block_current].data[block_pos];
        *p = val;
        block_pos += 4;
        if (block_pos >= BLOCK_MAX)
        {
                CPU_BLOCK_END();
        }
}

static inline void addquad(uint64_t val)
{
        uint64_t *p = (uint64_t *) &codeblock[block_current].data[block_pos];
        *p = val;
        block_pos += 8;
        if (block_pos >= BLOCK_MAX)
        {
                CPU_BLOCK_END();
        }
}

/*Current physical page of block being recompiled. -1 if no recompilation taking place */
***** CPU_NEW\CODEGEN.H

/*Current physical page of block being recompiled. -1 if no recompilation taking place */
*****

***** CPU\codegen.h

#endif
***** CPU_NEW\CODEGEN.H

void codegen_generate_reset();

int codegen_get_instruction_uop(codeblock_t *block, uint32_t pc, int *first_instruction, int *TOP);
void codegen_set_loop_start(struct ir_data_t *ir, int first_instruction);

#ifdef DEBUG_EXTRA
extern uint32_t instr_counts[256*256];
#endif
*****

***** CPU\codegen.h
***** CPU_NEW\CODEGEN.H

#endif
*****

