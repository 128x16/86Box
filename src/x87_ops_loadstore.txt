Comparing files CPU\x87_ops_loadstore.h and CPU_NEW\X87_OPS_LOADSTORE.H
***** CPU\x87_ops_loadstore.h
/*
 * 86Box        A hypervisor and IBM PC system emulator that specializes in
 *              running old operating systems and software designed for IBM
 *              PC systems and compatibles from 1981 through fairly recent
 *              system designs based on the PCI bus.
 *
 *              This file is part of the 86Box distribution.
 *
 *              x87 FPU instructions core.
 *
 * Version:     @(#)x87_ops_loadstore.h 1.0.2   2019/06/11
 *
 * Author:      Sarah Walker, <http://pcem-emulator.co.uk/>
 *              Miran Grca, <mgrca8@gmail.com>
 *              Copyright 2008-2019 Sarah Walker.
 *              Copyright 2016-2019 Miran Grca.
 */

static int opFILDiw_a16(uint32_t fetchdat)
{
***** CPU_NEW\X87_OPS_LOADSTORE.H
static int opFILDiw_a16(uint32_t fetchdat)
{
*****

***** CPU\x87_ops_loadstore.h
        fetch_ea_16(fetchdat);
                SEG_CHECK_READ(cpu_state.ea_seg);
        temp = geteaw(); if (cpu_state.abrt) return 1;
***** CPU_NEW\X87_OPS_LOADSTORE.H
        fetch_ea_16(fetchdat);
        SEG_CHECK_READ(cpu_state.ea_seg);
        temp = geteaw(); if (cpu_state.abrt) return 1;
*****

***** CPU\x87_ops_loadstore.h
        fetch_ea_32(fetchdat);
                SEG_CHECK_READ(cpu_state.ea_seg);
        temp = geteaw(); if (cpu_state.abrt) return 1;
***** CPU_NEW\X87_OPS_LOADSTORE.H
        fetch_ea_32(fetchdat);
        SEG_CHECK_READ(cpu_state.ea_seg);
        temp = geteaw(); if (cpu_state.abrt) return 1;
*****

***** CPU\x87_ops_loadstore.h
        temp64 = x87_fround(ST(0));
        seteaw((int16_t)temp64);
***** CPU_NEW\X87_OPS_LOADSTORE.H
        temp64 = x87_fround(ST(0));
/*                        if (temp64 > 32767 || temp64 < -32768)
                           fatal("FISTw overflow %i\n", temp64);*/
        seteaw((int16_t)temp64);
*****

***** CPU\x87_ops_loadstore.h
        temp64 = x87_fround(ST(0));
        seteaw((int16_t)temp64);
***** CPU_NEW\X87_OPS_LOADSTORE.H
        temp64 = x87_fround(ST(0));
/*                        if (temp64 > 32767 || temp64 < -32768)
                           fatal("FISTw overflow %i\n", temp64);*/
        seteaw((int16_t)temp64);
*****

***** CPU\x87_ops_loadstore.h
        temp64 = x87_fround(ST(0));
        seteaw((int16_t)temp64); if (cpu_state.abrt) return 1;
***** CPU_NEW\X87_OPS_LOADSTORE.H
        temp64 = x87_fround(ST(0));
/*                        if (temp64 > 32767 || temp64 < -32768)
                           fatal("FISTw overflow %i\n", temp64);*/
        seteaw((int16_t)temp64); if (cpu_state.abrt) return 1;
*****

***** CPU\x87_ops_loadstore.h
        temp64 = x87_fround(ST(0));
        seteaw((int16_t)temp64); if (cpu_state.abrt) return 1;
***** CPU_NEW\X87_OPS_LOADSTORE.H
        temp64 = x87_fround(ST(0));
/*                        if (temp64 > 32767 || temp64 < -32768)
                           fatal("FISTw overflow %i\n", temp64);*/
        seteaw((int16_t)temp64); if (cpu_state.abrt) return 1;
*****

***** CPU\x87_ops_loadstore.h
        fetch_ea_16(fetchdat);
                SEG_CHECK_READ(cpu_state.ea_seg);
        temp64 = geteaq(); if (cpu_state.abrt) return 1;
***** CPU_NEW\X87_OPS_LOADSTORE.H
        fetch_ea_16(fetchdat);
        SEG_CHECK_READ(cpu_state.ea_seg);
        temp64 = geteaq(); if (cpu_state.abrt) return 1;
*****

***** CPU\x87_ops_loadstore.h
        x87_push((double)temp64);
        cpu_state.MM[cpu_state.TOP].q = temp64;
        FP_LSTAG();
***** CPU_NEW\X87_OPS_LOADSTORE.H
        x87_push((double)temp64);
        cpu_state.MM[cpu_state.TOP&7].q = temp64;
        FP_LSTAG();
*****

***** CPU\x87_ops_loadstore.h
        fetch_ea_32(fetchdat);
                SEG_CHECK_READ(cpu_state.ea_seg);
        temp64 = geteaq(); if (cpu_state.abrt) return 1;
***** CPU_NEW\X87_OPS_LOADSTORE.H
        fetch_ea_32(fetchdat);
        SEG_CHECK_READ(cpu_state.ea_seg);
        temp64 = geteaq(); if (cpu_state.abrt) return 1;
*****

***** CPU\x87_ops_loadstore.h
        x87_push((double)temp64);
        cpu_state.MM[cpu_state.TOP].q = temp64;
        FP_LSTAG();
***** CPU_NEW\X87_OPS_LOADSTORE.H
        x87_push((double)temp64);
        cpu_state.MM[cpu_state.TOP&7].q = temp64;
        FP_LSTAG();
*****

***** CPU\x87_ops_loadstore.h
        SEG_CHECK_WRITE(cpu_state.ea_seg);
        if (cpu_state.tag[cpu_state.TOP] & TAG_UINT64)
                temp64 = cpu_state.MM[cpu_state.TOP].q;
        else
***** CPU_NEW\X87_OPS_LOADSTORE.H
        SEG_CHECK_WRITE(cpu_state.ea_seg);
        if (cpu_state.tag[cpu_state.TOP&7] & TAG_UINT64)
                temp64 = cpu_state.MM[cpu_state.TOP&7].q;
        else
*****

***** CPU\x87_ops_loadstore.h
        SEG_CHECK_WRITE(cpu_state.ea_seg);
        if (cpu_state.tag[cpu_state.TOP] & TAG_UINT64)
                temp64 = cpu_state.MM[cpu_state.TOP].q;
        else
***** CPU_NEW\X87_OPS_LOADSTORE.H
        SEG_CHECK_WRITE(cpu_state.ea_seg);
        if (cpu_state.tag[cpu_state.TOP&7] & TAG_UINT64)
                temp64 = cpu_state.MM[cpu_state.TOP&7].q;
        else
*****

***** CPU\x87_ops_loadstore.h
        fetch_ea_16(fetchdat);
                SEG_CHECK_READ(cpu_state.ea_seg);
        templ = geteal(); if (cpu_state.abrt) return 1;
***** CPU_NEW\X87_OPS_LOADSTORE.H
        fetch_ea_16(fetchdat);
        SEG_CHECK_READ(cpu_state.ea_seg);
        templ = geteal(); if (cpu_state.abrt) return 1;
*****

***** CPU\x87_ops_loadstore.h
        fetch_ea_32(fetchdat);
                SEG_CHECK_READ(cpu_state.ea_seg);
        templ = geteal(); if (cpu_state.abrt) return 1;
***** CPU_NEW\X87_OPS_LOADSTORE.H
        fetch_ea_32(fetchdat);
        SEG_CHECK_READ(cpu_state.ea_seg);
        templ = geteal(); if (cpu_state.abrt) return 1;
*****

***** CPU\x87_ops_loadstore.h
        temp64 = x87_fround(ST(0));
        seteal((int32_t)temp64);
***** CPU_NEW\X87_OPS_LOADSTORE.H
        temp64 = x87_fround(ST(0));
/*                        if (temp64 > 2147483647 || temp64 < -2147483647)
                           fatal("FISTl out of range! %i\n", temp64);*/
        seteal((int32_t)temp64);
*****

***** CPU\x87_ops_loadstore.h
        temp64 = x87_fround(ST(0));
        seteal((int32_t)temp64);
***** CPU_NEW\X87_OPS_LOADSTORE.H
        temp64 = x87_fround(ST(0));
/*                        if (temp64 > 2147483647 || temp64 < -2147483647)
                           fatal("FISTl out of range! %i\n", temp64);*/
        seteal((int32_t)temp64);
*****

***** CPU\x87_ops_loadstore.h
        temp64 = x87_fround(ST(0));
        seteal((int32_t)temp64); if (cpu_state.abrt) return 1;
***** CPU_NEW\X87_OPS_LOADSTORE.H
        temp64 = x87_fround(ST(0));
/*                        if (temp64 > 2147483647 || temp64 < -2147483647)
                           fatal("FISTl out of range! %i\n", temp64);*/
        seteal((int32_t)temp64); if (cpu_state.abrt) return 1;
*****

***** CPU\x87_ops_loadstore.h
        temp64 = x87_fround(ST(0));
        seteal((int32_t)temp64); if (cpu_state.abrt) return 1;
***** CPU_NEW\X87_OPS_LOADSTORE.H
        temp64 = x87_fround(ST(0));
/*                        if (temp64 > 2147483647 || temp64 < -2147483647)
                           fatal("FISTl out of range! %i\n", temp64);*/
        seteal((int32_t)temp64); if (cpu_state.abrt) return 1;
*****

***** CPU\x87_ops_loadstore.h
        fetch_ea_16(fetchdat);
        SEG_CHECK_READ(cpu_state.ea_seg);               
        t=x87_ld80(); if (cpu_state.abrt) return 1;
***** CPU_NEW\X87_OPS_LOADSTORE.H
        fetch_ea_16(fetchdat);
        SEG_CHECK_READ(cpu_state.ea_seg);
        t=x87_ld80(); if (cpu_state.abrt) return 1;
*****

***** CPU\x87_ops_loadstore.h
        fetch_ea_32(fetchdat);
                SEG_CHECK_READ(cpu_state.ea_seg);
        t.i = geteaq(); if (cpu_state.abrt) return 1;
***** CPU_NEW\X87_OPS_LOADSTORE.H
        fetch_ea_32(fetchdat);
        SEG_CHECK_READ(cpu_state.ea_seg);
        t.i = geteaq(); if (cpu_state.abrt) return 1;
*****

***** CPU\x87_ops_loadstore.h
        fetch_ea_16(fetchdat);
                SEG_CHECK_READ(cpu_state.ea_seg);
        ts.i = geteal(); if (cpu_state.abrt) return 1;
***** CPU_NEW\X87_OPS_LOADSTORE.H
        fetch_ea_16(fetchdat);
        SEG_CHECK_READ(cpu_state.ea_seg);
        ts.i = geteal(); if (cpu_state.abrt) return 1;
*****

