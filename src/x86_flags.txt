Comparing files CPU\x86_flags.h and CPU_NEW\X86_FLAGS.H
***** CPU\x86_flags.h
/* Copyright holders: Sarah Walker
   see COPYING for more details
*/
extern int tempc;

***** CPU_NEW\X86_FLAGS.H
extern int tempc;

*****

***** CPU\x86_flags.h

        FLAGS_INC8,
***** CPU_NEW\X86_FLAGS.H

        FLAGS_ROL8,
        FLAGS_ROL16,
        FLAGS_ROL32,

        FLAGS_ROR8,
        FLAGS_ROR16,
        FLAGS_ROR32,

        FLAGS_INC8,
*****

***** CPU\x86_flags.h
        FLAGS_DEC16,
        FLAGS_DEC32
};
***** CPU_NEW\X86_FLAGS.H
        FLAGS_DEC16,
        FLAGS_DEC32,

        FLAGS_ADC8,
        FLAGS_ADC16,
        FLAGS_ADC32,

        FLAGS_SBC8,
        FLAGS_SBC16,
        FLAGS_SBC32
};
*****

***** CPU\x86_flags.h

static __inline int ZF_SET()
{
***** CPU_NEW\X86_FLAGS.H

static inline int ZF_SET()
{
*****

***** CPU\x86_flags.h
                case FLAGS_DEC32:
                return !cpu_state.flags_res;
***** CPU_NEW\X86_FLAGS.H
                case FLAGS_DEC32:
                case FLAGS_ADC8:
                case FLAGS_ADC16:
                case FLAGS_ADC32:
                case FLAGS_SBC8:
                case FLAGS_SBC16:
                case FLAGS_SBC32:
                return !cpu_state.flags_res;
*****

***** CPU\x86_flags.h
                
                case FLAGS_UNKNOWN:
***** CPU_NEW\X86_FLAGS.H
                
                case FLAGS_ROL8:
                case FLAGS_ROL16:
                case FLAGS_ROL32:
                case FLAGS_ROR8:
                case FLAGS_ROR16:
                case FLAGS_ROR32:
                case FLAGS_UNKNOWN:
*****

***** CPU\x86_flags.h
                return cpu_state.flags & Z_FLAG;

                default:
                return 0;
        }
}
***** CPU_NEW\X86_FLAGS.H
                return cpu_state.flags & Z_FLAG;
        }
        return 0;
}
*****

***** CPU\x86_flags.h

static __inline int NF_SET()
{
***** CPU_NEW\X86_FLAGS.H

static inline int NF_SET()
{
*****

***** CPU\x86_flags.h
                case FLAGS_DEC8:
                return cpu_state.flags_res & 0x80;
***** CPU_NEW\X86_FLAGS.H
                case FLAGS_DEC8:
                case FLAGS_ADC8:
                case FLAGS_SBC8:
                return cpu_state.flags_res & 0x80;
*****

***** CPU\x86_flags.h
                case FLAGS_DEC16:
                return cpu_state.flags_res & 0x8000;
***** CPU_NEW\X86_FLAGS.H
                case FLAGS_DEC16:
                case FLAGS_ADC16:
                case FLAGS_SBC16:
                return cpu_state.flags_res & 0x8000;
*****

***** CPU\x86_flags.h
                case FLAGS_DEC32:
                return cpu_state.flags_res & 0x80000000;
***** CPU_NEW\X86_FLAGS.H
                case FLAGS_DEC32:
                case FLAGS_ADC32:
                case FLAGS_SBC32:
                return cpu_state.flags_res & 0x80000000;
*****

***** CPU\x86_flags.h
                
                case FLAGS_UNKNOWN:
***** CPU_NEW\X86_FLAGS.H
                
                case FLAGS_ROL8:
                case FLAGS_ROL16:
                case FLAGS_ROL32:
                case FLAGS_ROR8:
                case FLAGS_ROR16:
                case FLAGS_ROR32:
                case FLAGS_UNKNOWN:
*****

***** CPU\x86_flags.h
                return cpu_state.flags & N_FLAG;

                default:
                return 0;
        }
}
***** CPU_NEW\X86_FLAGS.H
                return cpu_state.flags & N_FLAG;
        }
        return 0;
}
*****

***** CPU\x86_flags.h

static __inline int PF_SET()
{
***** CPU_NEW\X86_FLAGS.H

static inline int PF_SET()
{
*****

***** CPU\x86_flags.h
                case FLAGS_DEC32:
                return znptable8[cpu_state.flags_res & 0xff] & P_FLAG;
***** CPU_NEW\X86_FLAGS.H
                case FLAGS_DEC32:
                case FLAGS_ADC8:
                case FLAGS_ADC16:
                case FLAGS_ADC32:
                case FLAGS_SBC8:
                case FLAGS_SBC16:
                case FLAGS_SBC32:
                return znptable8[cpu_state.flags_res & 0xff] & P_FLAG;
*****

***** CPU\x86_flags.h
                
                case FLAGS_UNKNOWN:
***** CPU_NEW\X86_FLAGS.H
                
                case FLAGS_ROL8:
                case FLAGS_ROL16:
                case FLAGS_ROL32:
                case FLAGS_ROR8:
                case FLAGS_ROR16:
                case FLAGS_ROR32:
                case FLAGS_UNKNOWN:
*****

***** CPU\x86_flags.h
                return cpu_state.flags & P_FLAG;

                default:
                return 0;
        }
}
***** CPU_NEW\X86_FLAGS.H
                return cpu_state.flags & P_FLAG;
        }
        return 0;
}
*****

***** CPU\x86_flags.h

static __inline int VF_SET()
{
***** CPU_NEW\X86_FLAGS.H

static inline int VF_SET()
{
*****

***** CPU\x86_flags.h
                
                case FLAGS_ADD8:
***** CPU_NEW\X86_FLAGS.H
                
                case FLAGS_ADC8:
                case FLAGS_ADD8:
*****

***** CPU\x86_flags.h
0x80);
                                case FLAGS_ADD16:
                case FLAGS_INC16:
***** CPU_NEW\X86_FLAGS.H
0x80);
                case FLAGS_ADC16:
                case FLAGS_ADD16:
                case FLAGS_INC16:
*****

***** CPU\x86_flags.h
& 0x8000);
                                case FLAGS_ADD32:
                case FLAGS_INC32:
***** CPU_NEW\X86_FLAGS.H
& 0x8000);
                case FLAGS_ADC32:
                case FLAGS_ADD32:
                case FLAGS_INC32:
*****

***** CPU\x86_flags.h
es) & 0x80000000);
                               
                case FLAGS_SUB8:
***** CPU_NEW\X86_FLAGS.H
es) & 0x80000000);
                                
                case FLAGS_SBC8:
                case FLAGS_SUB8:
*****

***** CPU\x86_flags.h
                return ((cpu_state.flags_op1 ^ cpu_state.flags_op2) & (cpu_state.flags_op1 ^ cpu_state.flags_res) & 0x80);
                                case FLAGS_SUB16:
                case FLAGS_DEC16:
***** CPU_NEW\X86_FLAGS.H
                return ((cpu_state.flags_op1 ^ cpu_state.flags_op2) & (cpu_state.flags_op1 ^ cpu_state.flags_res) & 0x80);
                case FLAGS_SBC16:
                case FLAGS_SUB16:
                case FLAGS_DEC16:
*****

***** CPU\x86_flags.h
                return ((cpu_state.flags_op1 ^ cpu_state.flags_op2) & (cpu_state.flags_op1 ^ cpu_state.flags_res) & 0x8000);
                                case FLAGS_SUB32:
                case FLAGS_DEC32:
***** CPU_NEW\X86_FLAGS.H
                return ((cpu_state.flags_op1 ^ cpu_state.flags_op2) & (cpu_state.flags_op1 ^ cpu_state.flags_res) & 0x8000);
                case FLAGS_SBC32:
                case FLAGS_SUB32:
                case FLAGS_DEC32:
*****

***** CPU\x86_flags.h
                return ((cpu_state.flags_op2 == 1) && (cpu_state.flags_op1 & 0x80000000));
                
                case FLAGS_UNKNOWN:
***** CPU_NEW\X86_FLAGS.H
                return ((cpu_state.flags_op2 == 1) && (cpu_state.flags_op1 & 0x80000000));

                case FLAGS_ROL8:
                return (cpu_state.flags_res ^ (cpu_state.flags_res >> 7)) & 1;
                case FLAGS_ROL16:
                return (cpu_state.flags_res ^ (cpu_state.flags_res >> 15)) & 1;
                case FLAGS_ROL32:
                return (cpu_state.flags_res ^ (cpu_state.flags_res >> 31)) & 1;

                case FLAGS_ROR8:
                return (cpu_state.flags_res ^ (cpu_state.flags_res >> 1)) & 0x40;
                case FLAGS_ROR16:
                return (cpu_state.flags_res ^ (cpu_state.flags_res >> 1)) & 0x4000;
                case FLAGS_ROR32:
                return (cpu_state.flags_res ^ (cpu_state.flags_res >> 1)) & 0x40000000;

                case FLAGS_UNKNOWN:
*****

***** CPU\x86_flags.h
                return cpu_state.flags & V_FLAG;

                default:
                return 0;
        }
}
***** CPU_NEW\X86_FLAGS.H
                return cpu_state.flags & V_FLAG;
        }
        return 0;
}
*****

***** CPU\x86_flags.h

static __inline int AF_SET()
{
***** CPU_NEW\X86_FLAGS.H

static inline int AF_SET()
{
*****

***** CPU\x86_flags.h

                case FLAGS_SUB8:
***** CPU_NEW\X86_FLAGS.H

                case FLAGS_ADC8:
                return ((cpu_state.flags_res & 0xf) < (cpu_state.flags_op1 & 0xf)) ||
                        ((cpu_state.flags_res & 0xf) == (cpu_state.flags_op1 & 0xf) && cpu_state.flags_op2 == 0xff);
                case FLAGS_ADC16:
                return ((cpu_state.flags_res & 0xf) < (cpu_state.flags_op1 & 0xf)) ||
                        ((cpu_state.flags_res & 0xf) == (cpu_state.flags_op1 & 0xf) && cpu_state.flags_op2 == 0xffff);
                case FLAGS_ADC32:
                return ((cpu_state.flags_res & 0xf) < (cpu_state.flags_op1 & 0xf)) ||
                        ((cpu_state.flags_res & 0xf) == (cpu_state.flags_op1 & 0xf) && cpu_state.flags_op2 == 0xffffffff);

                case FLAGS_SUB8:
*****

***** CPU\x86_flags.h

                case FLAGS_UNKNOWN:
***** CPU_NEW\X86_FLAGS.H

                case FLAGS_SBC8:
                case FLAGS_SBC16:
                case FLAGS_SBC32:
                return ((cpu_state.flags_op1 & 0xf) < (cpu_state.flags_op2 & 0xf)) ||
                        ((cpu_state.flags_op1 & 0xf) == (cpu_state.flags_op2 & 0xf) && (cpu_state.flags_res & 0xf) != 0);
                
                case FLAGS_ROL8:
                case FLAGS_ROL16:
                case FLAGS_ROL32:
                case FLAGS_ROR8:
                case FLAGS_ROR16:
                case FLAGS_ROR32:
                case FLAGS_UNKNOWN:
*****

***** CPU\x86_flags.h
                return cpu_state.flags & A_FLAG;

                default:
                return 0;
        }
}
***** CPU_NEW\X86_FLAGS.H
                return cpu_state.flags & A_FLAG;
        }
        return 0;
}
*****

***** CPU\x86_flags.h

static __inline int CF_SET()
{
***** CPU_NEW\X86_FLAGS.H

static inline int CF_SET()
{
*****

***** CPU\x86_flags.h
                case FLAGS_ADD8:
                return (cpu_state.flags_op1 + cpu_state.flags_op2) & 0x100;
                case FLAGS_ADD16:
                return (cpu_state.flags_op1 + cpu_state.flags_op2) & 0x10000;
                case FLAGS_ADD32:
***** CPU_NEW\X86_FLAGS.H
                case FLAGS_ADD8:
                return ((cpu_state.flags_op1 + cpu_state.flags_op2) & 0x100) ? 1 : 0;
                case FLAGS_ADD16:
                return ((cpu_state.flags_op1 + cpu_state.flags_op2) & 0x10000) ? 1 : 0;
                case FLAGS_ADD32:
*****

***** CPU\x86_flags.h

                case FLAGS_SUB8:
***** CPU_NEW\X86_FLAGS.H

                case FLAGS_ADC8:
                return (cpu_state.flags_res < cpu_state.flags_op1) ||
                        (cpu_state.flags_res == cpu_state.flags_op1 && cpu_state.flags_op2 == 0xff);
                case FLAGS_ADC16:
                return (cpu_state.flags_res < cpu_state.flags_op1) ||
                        (cpu_state.flags_res == cpu_state.flags_op1 && cpu_state.flags_op2 == 0xffff);
                case FLAGS_ADC32:
                return (cpu_state.flags_res < cpu_state.flags_op1) ||
                        (cpu_state.flags_res == cpu_state.flags_op1 && cpu_state.flags_op2 == 0xffffffff);

                case FLAGS_SUB8:
*****

***** CPU\x86_flags.h

                case FLAGS_SHL8:
                return (cpu_state.flags_op1 << (cpu_state.flags_op2 - 1)) & 0x80;
                case FLAGS_SHL16:
                return (cpu_state.flags_op1 << (cpu_state.flags_op2 - 1)) & 0x8000;
                case FLAGS_SHL32:
                return (cpu_state.flags_op1 << (cpu_state.flags_op2 - 1)) & 0x80000000;

***** CPU_NEW\X86_FLAGS.H

                case FLAGS_SBC8:
                case FLAGS_SBC16:
                case FLAGS_SBC32:
                return (cpu_state.flags_op1 < cpu_state.flags_op2) ||
                        (cpu_state.flags_op1 == cpu_state.flags_op2 && cpu_state.flags_res != 0);

                case FLAGS_SHL8:
                return ((cpu_state.flags_op1 << (cpu_state.flags_op2 - 1)) & 0x80) ? 1 : 0;
                case FLAGS_SHL16:
                return ((cpu_state.flags_op1 << (cpu_state.flags_op2 - 1)) & 0x8000) ? 1 : 0;
                case FLAGS_SHL32:
                return ((cpu_state.flags_op1 << (cpu_state.flags_op2 - 1)) & 0x80000000) ? 1 : 0;

*****

***** CPU\x86_flags.h
                return 0;
                
***** CPU_NEW\X86_FLAGS.H
                return 0;

                case FLAGS_ROL8:
                case FLAGS_ROL16:
                case FLAGS_ROL32:
                return cpu_state.flags_res & 1;
                
                case FLAGS_ROR8:
                return (cpu_state.flags_res & 0x80) ? 1 : 0;
                case FLAGS_ROR16:
                return (cpu_state.flags_res & 0x8000) ? 1 :0;
                case FLAGS_ROR32:
                return (cpu_state.flags_res & 0x80000000) ? 1 : 0;
                
*****

***** CPU\x86_flags.h
                return cpu_state.flags & C_FLAG;

                default:
                return 0;
        }
}
***** CPU_NEW\X86_FLAGS.H
                return cpu_state.flags & C_FLAG;
        }
        return 0;
}
*****

***** CPU\x86_flags.h

static __inline void flags_rebuild()
{
***** CPU_NEW\X86_FLAGS.H

//#define ZF_SET() (flags & Z_FLAG)
//#define NF_SET() (flags & N_FLAG)
//#define PF_SET() (flags & P_FLAG)
//#define VF_SET() (flags & V_FLAG)
//#define CF_SET() (flags & C_FLAG)
//#define AF_SET() (flags & A_FLAG)

static inline void flags_rebuild()
{
*****

***** CPU\x86_flags.h

static __inline void flags_extract()
{
***** CPU_NEW\X86_FLAGS.H

static inline void flags_extract()
{
*****

***** CPU\x86_flags.h

static __inline void flags_rebuild_c()
{
***** CPU_NEW\X86_FLAGS.H

static inline void flags_rebuild_c()
{
*****

***** CPU\x86_flags.h
                if (CF_SET())
                   cpu_state.flags |=  C_FLAG;
                else
                   cpu_state.flags &= ~C_FLAG;
        }                
***** CPU_NEW\X86_FLAGS.H
                if (CF_SET())
                        cpu_state.flags |=  C_FLAG;
                else
                        cpu_state.flags &= ~C_FLAG;
        }                
*****

***** CPU\x86_flags.h

static __inline void setznp8(uint8_t val)
{
***** CPU_NEW\X86_FLAGS.H

static inline int flags_res_valid()
{
        if (cpu_state.flags_op == FLAGS_UNKNOWN ||
            (cpu_state.flags_op >= FLAGS_ROL8 && cpu_state.flags_op <= FLAGS_ROR32))
                return 0;

        return 1;
}

static inline void setznp8(uint8_t val)
{
*****

***** CPU\x86_flags.h
}
static __inline void setznp16(uint16_t val)
{
***** CPU_NEW\X86_FLAGS.H
}
static inline void setznp16(uint16_t val)
{
*****

***** CPU\x86_flags.h
}
static __inline void setznp32(uint32_t val)
{
***** CPU_NEW\X86_FLAGS.H
}
static inline void setznp32(uint32_t val)
{
*****

***** CPU\x86_flags.h

static __inline void setadd8(uint8_t a, uint8_t b)
{
***** CPU_NEW\X86_FLAGS.H

#define set_flags_rotate(op, res)               \
        cpu_state.flags_op = op;                \
        cpu_state.flags_res = res;

static inline void setadd8(uint8_t a, uint8_t b)
{
*****

***** CPU\x86_flags.h
}
static __inline void setadd16(uint16_t a, uint16_t b)
{
***** CPU_NEW\X86_FLAGS.H
}
static inline void setadd16(uint16_t a, uint16_t b)
{
*****

***** CPU\x86_flags.h
}
static __inline void setadd32(uint32_t a, uint32_t b)
{
***** CPU_NEW\X86_FLAGS.H
}
static inline void setadd32(uint32_t a, uint32_t b)
{
*****

***** CPU\x86_flags.h
}
static __inline void setadd8nc(uint8_t a, uint8_t b)
{
***** CPU_NEW\X86_FLAGS.H
}
static inline void setadd8nc(uint8_t a, uint8_t b)
{
*****

***** CPU\x86_flags.h
}
static __inline void setadd16nc(uint16_t a, uint16_t b)
{
***** CPU_NEW\X86_FLAGS.H
}
static inline void setadd16nc(uint16_t a, uint16_t b)
{
*****

***** CPU\x86_flags.h
}
static __inline void setadd32nc(uint32_t a, uint32_t b)
{
***** CPU_NEW\X86_FLAGS.H
}
static inline void setadd32nc(uint32_t a, uint32_t b)
{
*****

***** CPU\x86_flags.h

static __inline void setsub8(uint8_t a, uint8_t b)
{
***** CPU_NEW\X86_FLAGS.H

static inline void setsub8(uint8_t a, uint8_t b)
{
*****

***** CPU\x86_flags.h
}
static __inline void setsub16(uint16_t a, uint16_t b)
{
***** CPU_NEW\X86_FLAGS.H
}
static inline void setsub16(uint16_t a, uint16_t b)
{
*****

***** CPU\x86_flags.h
}
static __inline void setsub32(uint32_t a, uint32_t b)
{
***** CPU_NEW\X86_FLAGS.H
}
static inline void setsub32(uint32_t a, uint32_t b)
{
*****

***** CPU\x86_flags.h

static __inline void setsub8nc(uint8_t a, uint8_t b)
{
***** CPU_NEW\X86_FLAGS.H

static inline void setsub8nc(uint8_t a, uint8_t b)
{
*****

***** CPU\x86_flags.h
}
static __inline void setsub16nc(uint16_t a, uint16_t b)
{
***** CPU_NEW\X86_FLAGS.H
}
static inline void setsub16nc(uint16_t a, uint16_t b)
{
*****

***** CPU\x86_flags.h
}
static __inline void setsub32nc(uint32_t a, uint32_t b)
{
***** CPU_NEW\X86_FLAGS.H
}
static inline void setsub32nc(uint32_t a, uint32_t b)
{
*****

***** CPU\x86_flags.h

static __inline void setadc8(uint8_t a, uint8_t b)
{
        uint16_t c=(uint16_t)a+(uint16_t)b+tempc;
        cpu_state.flags_op = FLAGS_UNKNOWN;
        cpu_state.flags&=~0x8D5;
        cpu_state.flags|=znptable8[c&0xFF];
        if (c&0x100) cpu_state.flags|=C_FLAG;
        if (!((a^b)&0x80)&&((a^c)&0x80)) cpu_state.flags|=V_FLAG;
        if (((a&0xF)+(b&0xF))&0x10)      cpu_state.flags|=A_FLAG;
}
static __inline void setadc16(uint16_t a, uint16_t b)
{
        uint32_t c=(uint32_t)a+(uint32_t)b+tempc;
        cpu_state.flags_op = FLAGS_UNKNOWN;
        cpu_state.flags&=~0x8D5;
        cpu_state.flags|=znptable16[c&0xFFFF];
        if (c&0x10000) cpu_state.flags|=C_FLAG;
        if (!((a^b)&0x8000)&&((a^c)&0x8000)) cpu_state.flags|=V_FLAG;
        if (((a&0xF)+(b&0xF))&0x10)      cpu_state.flags|=A_FLAG;
}
static __inline void setadc32(uint32_t a, uint32_t b)
{
        uint32_t c=(uint32_t)a+(uint32_t)b+tempc;
        cpu_state.flags_op = FLAGS_UNKNOWN;
        cpu_state.flags&=~0x8D5;
        cpu_state.flags|=((c&0x80000000)?N_FLAG:((!c)?Z_FLAG:0));
        cpu_state.flags|=(znptable8[c&0xFF]&P_FLAG);
        if ((c<a) || (c==a && tempc)) cpu_state.flags|=C_FLAG;
        if (!((a^b)&0x80000000)&&((a^c)&0x80000000)) cpu_state.flags|=V_FLAG;
        if (((a&0xF)+(b&0xF)+tempc)&0x10)      cpu_state.flags|=A_FLAG;
}
***** CPU_NEW\X86_FLAGS.H

static inline void setadc8(uint8_t a, uint8_t b)
{
        cpu_state.flags_op1 = a;
        cpu_state.flags_op2 = b;
        cpu_state.flags_res = (a + b + tempc) & 0xff;
        cpu_state.flags_op = FLAGS_ADC8;
}
static inline void setadc16(uint16_t a, uint16_t b)
{
        cpu_state.flags_op1 = a;
        cpu_state.flags_op2 = b;
        cpu_state.flags_res = (a + b + tempc) & 0xffff;
        cpu_state.flags_op = FLAGS_ADC16;
}
static inline void setadc32(uint32_t a, uint32_t b)
{
        cpu_state.flags_op1 = a;
        cpu_state.flags_op2 = b;
        cpu_state.flags_res = a + b + tempc;
        cpu_state.flags_op = FLAGS_ADC32;
}
*****

***** CPU\x86_flags.h


static __inline void setsbc8(uint8_t a, uint8_t b)
{
        uint16_t c=(uint16_t)a-(((uint16_t)b)+tempc);
        cpu_state.flags_op = FLAGS_UNKNOWN;
        cpu_state.flags&=~0x8D5;
        cpu_state.flags|=znptable8[c&0xFF];
        if (c&0x100) cpu_state.flags|=C_FLAG;
        if ((a^b)&(a^c)&0x80) cpu_state.flags|=V_FLAG;
        if (((a&0xF)-(b&0xF))&0x10)      cpu_state.flags|=A_FLAG;
}
static __inline void setsbc16(uint16_t a, uint16_t b)
{
        uint32_t c=(uint32_t)a-(((uint32_t)b)+tempc);
        cpu_state.flags_op = FLAGS_UNKNOWN;
        cpu_state.flags&=~0x8D5;
        cpu_state.flags|=(znptable16[c&0xFFFF]&~4);
        cpu_state.flags|=(znptable8[c&0xFF]&4);
        if (c&0x10000) cpu_state.flags|=C_FLAG;
        if ((a^b)&(a^c)&0x8000) cpu_state.flags|=V_FLAG;
        if (((a&0xF)-(b&0xF))&0x10)      cpu_state.flags|=A_FLAG;
}
***** CPU_NEW\X86_FLAGS.H

static inline void setsbc8(uint8_t a, uint8_t b)
{
        cpu_state.flags_op1 = a;
        cpu_state.flags_op2 = b;
        cpu_state.flags_res = (a - (b + tempc)) & 0xff;
        cpu_state.flags_op = FLAGS_SBC8;
}
static inline void setsbc16(uint16_t a, uint16_t b)
{
        cpu_state.flags_op1 = a;
        cpu_state.flags_op2 = b;
        cpu_state.flags_res = (a - (b + tempc)) & 0xffff;
        cpu_state.flags_op = FLAGS_SBC16;
}
static inline void setsbc32(uint32_t a, uint32_t b)
{
        cpu_state.flags_op1 = a;
        cpu_state.flags_op2 = b;
        cpu_state.flags_res = a - (b + tempc);
        cpu_state.flags_op = FLAGS_SBC32;
}
*****

***** CPU\x86_flags.h

static __inline void setsbc32(uint32_t a, uint32_t b)
{
        uint32_t c=(uint32_t)a-(((uint32_t)b)+tempc);
        cpu_state.flags_op = FLAGS_UNKNOWN;
        cpu_state.flags&=~0x8D5;
        cpu_state.flags|=((c&0x80000000)?N_FLAG:((!c)?Z_FLAG:0));
        cpu_state.flags|=(znptable8[c&0xFF]&P_FLAG);
        if ((c>a) || (c==a && tempc)) cpu_state.flags|=C_FLAG;
        if ((a^b)&(a^c)&0x80000000) cpu_state.flags|=V_FLAG;
        if (((a&0xF)-((b&0xF)+tempc))&0x10)      cpu_state.flags|=A_FLAG;
}

extern void cpu_386_flags_extract();
***** CPU_NEW\X86_FLAGS.H

extern void cpu_386_flags_extract();
*****

