diff --git a/src/86box.c b/src/86box.c
index a14f51c41..3c96d88a4 100644
--- a/src/86box.c
+++ b/src/86box.c
@@ -1263,9 +1263,9 @@ pc_run(void)
     startblit();
     cpu_exec(cpu_s->rspeed / 100);
 #ifdef USE_GDBSTUB /* avoid a KBC FIFO overflow when CPU emulation is stalled */
-    if (gdbstub_step == GDBSTUB_EXEC)
+    // if (gdbstub_step == GDBSTUB_EXEC)
 #endif
-        mouse_process();
+        // mouse_process();
     joystick_process();
     endblit();
 
diff --git a/src/device/mouse.c b/src/device/mouse.c
index 7eb6a08a9..329397d43 100644
--- a/src/device/mouse.c
+++ b/src/device/mouse.c
@@ -27,6 +27,8 @@
 #define HAVE_STDARG_H
 #include <86box/86box.h>
 #include <86box/device.h>
+#include <86box/timer.h>
+#include <86box/gdbstub.h>
 #include <86box/mouse.h>
 
 typedef struct {
@@ -45,6 +47,8 @@ int mouse_x,
 double mouse_x_abs,
     mouse_y_abs;
 
+pc_timer_t mouse_timer; /* mouse event timer */
+
 static const device_t mouse_none_device = {
     .name          = "None",
     .internal_name = "none",
@@ -141,6 +145,20 @@ mouse_close(void)
     mouse_priv     = NULL;
     mouse_nbut     = 0;
     mouse_dev_poll = NULL;
+
+    timer_stop(&mouse_timer);
+}
+
+static void
+mouse_timer_poll(void *priv)
+{
+    // timer_on_auto(&mouse_timer, 1388.0 + (8.0 / 9.0));
+    timer_on_auto(&mouse_timer, 277.0 + (7.0 / 9.0));
+
+#ifdef USE_GDBSTUB /* avoid a KBC FIFO overflow when CPU emulation is stalled */
+    if (gdbstub_step == GDBSTUB_EXEC)
+#endif
+        mouse_process();
 }
 
 void
@@ -165,6 +183,9 @@ mouse_reset(void)
 
     if (mouse_curr != NULL)
         mouse_priv = device_add(mouse_curr);
+
+    timer_add(&mouse_timer, mouse_timer_poll, NULL, 0);
+    timer_on_auto(&mouse_timer, 10000.0);
 }
 
 /* Callback from the hardware driver. */
